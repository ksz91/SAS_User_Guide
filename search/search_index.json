{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"\u00dcbersicht Eigene Formate Gruppieren Sortieren Totale und Subtotale Transponieren Horizontalisierung Vertikalisierung Datens\u00e4tze verbinden Append Join mittels Abfrage MERGE Tabellen und Reports Zusammenfassungstabelle PROC TABULATE PROC REPORT Stichprobenanalyse PROC SURVEYFREQ PROC SURVEYMEANS Daten exportieren An Microsoft Excel senden ODS Excel N\u00fctzlicher Code put(), substr(), scan() CASE Statement SAS Enterprise Guide 8.3 Anwendungsroutinen Backup-Intervall Navigation und Ansicht Server-Migration Libname Statements Export mit ODS Excel Grosse Datenmengen Komprimieren und L\u00f6schen Effiziente Sortierung Export mittels Data Step Neue Rohdatenablage Einlesen mit PROC IMPORT Routine \u00abDaten importieren\u00bb","title":"\u00dcbersicht"},{"location":"index.html#ubersicht","text":"","title":"\u00dcbersicht"},{"location":"big.html","text":"Umgang mit grossen Datenmengen Bei der Arbeit mit sehr grossen Datenmengen kann es zu Ressourcen- bzw. Speicherproblemen kommen. Um dem entgegenzuwirken gibt es einige einfache M\u00f6glichkeiten. Output komprimieren Abfragen im SAS Enterprise Guide k\u00f6nnen um diverse Optionen erg\u00e4nzt werden: Optionen -> Optionen f\u00fcr diese Abfrage -> Ergebnisse Im Feld Optionen: kann SQL-Code eingegeben werden. In diesem Fall compress=yes . Dies f\u00fchrt dazu, dass der Output der Abfrage komprimiert wird und weniger Speicherplatz auf dem SAS-Server in Anspruch nimmt. Zudem sollte die Abfrage so auch schneller durchlaufen. L\u00f6schen mit PROC DATASETS Nicht mehr ben\u00f6tigte Datens\u00e4tze brauchen unn\u00f6tig Speicherplatz im WORK-Verzeichnis und sollten deshalb gel\u00f6scht werden. Zum Beispiel: Wenn mehrere Datens\u00e4tze durch einen Merge zu einem neuen Datensatz zusammengef\u00fcgt werden, k\u00f6nnen nach dem Merge die urspr\u00fcnglichen Datens\u00e4tze gel\u00f6scht werden. proc datasets lib=work; delete dataset1 dataset2 dataset3; run; Dieser Ansatz ist eher f\u00fcr SAS-Projekte mit Programmierung geeignet, kann aber theoretisch auch mit vordefinierten Abfragen und Anwendungsroutinen des SAS Enterprise Guide kombiniert werden. Dazu einfach den Code in ein Programm schreiben, rechter Mausklick auf den zu l\u00f6schenden Datensatz und \u00abVerkn\u00fcpfen mit\u00bb und das Programm mit dem Proc Datasets-Statement ausw\u00e4hlen. WICHTIG: Beim Schliessen des SAS Enterprise Guide werden alle Daten im WORK-Verzeichnis gel\u00f6scht. Das L\u00f6schen mittels Proc Datasets ist also nicht bei jedem noch so kleinen SAS-Projekt n\u00f6tig. Wichtig ist es eher bei sehr grossen Projekten mit vielen Abfragen bzw. Programmen und mit grossen Datens\u00e4tzen. Effiziente Sortierung Das Sortieren von Datens\u00e4tzen kann vor allem bei grossen Datens\u00e4tzen sehr ressourcenintensiv sein. Es gibt zwei Ans\u00e4tze um sowohl Zeit als auch Speicherplatz einzusparen. Das Proc Sort-Statement um die Option TAGSORT erg\u00e4nzen: proc sort data=person tagsort ; by alter; run; Wenn nur ein Subset eines Datensatzes sortiert werden soll, wird das oft in zwei Schritten gemacht: data person_f (where=(geschlecht=\"F\")); set person; run; proc sort data=person_f out=person_f_sorted; by alter; run; Ein Kombinieren dieser beiden Schritte spart sowohl Zeit als auch Speicherplatz: proc sort data=person (where=(geschlecht=\"F\")) out=person_f_sorted; by alter; run; Auswahl und Filter Aus jeder Abfrage resultierte ein neuer Datensatz, der im WORK-Verzeichnis gespeichert wird. Je kleiner dieser ist, desto schneller l\u00e4uft die Abfrage durch und desto weniger Speicher wird im WORK-Verzeichnis in Anspruch genommen. Deshalb sind folgende zwei Grunds\u00e4tze wichtig: Auswahl der Variablen: So fr\u00fch wie m\u00f6glich nur noch mit den relevanten Variablen arbeiten. Am besten bereits bei der ersten Abfrage die unn\u00f6tigen Variablen weglassen. Filter setzen: So fr\u00fch wie m\u00f6glich filtern. Wenn f\u00fcr eine Auswertung nur eine bestimmte Personengruppe ben\u00f6tigt wird, sollte am besten gleich in der ersten Abfrage nach dieser gefiltert werden. Export mittels Data Step Um einen Datensatz aus SAS in ein externes File zu exportieren, wird oft ODS und ein Proc Print-Statement verwendet. Ist der Datensatz allerdings sehr gross, dann kann das extrem lange dauern. In diesem Fall bietet sich unter Umst\u00e4nden ein Export mittels Data Step und PUT-Statement an: data _null_; set table1; file=\"<\u2009Pfad\u2009>\\Dateiname.csv\" encoding=\"UTF-8\" dlm=\";\"; if _n_=1 then put \"Name;Geschlecht;Merkmal;Wert\"; put Name Geschlecht Merkmal Wert; run; dlm : Bestimmt das Trennzeichen zwischen den Datenreihen, in diesem Fall ein Semikolon. if _n_=1 : Der Nachteil dieser Methode ist, dass die Spaltennamen nicht exportiert werden, sondern nur die Daten. Deshalb muss die erste Zeile mit den Spaltennamen manuell hinzugef\u00fcgt werden. Wichtig ist es, die Spaltennamen mit dem korrekten Trennzeichen aneinanderzuh\u00e4ngen und in Anf\u00fchrungszeichen zu setzen. put : Hier werden alle Variablen erfasst, die exportiert werden sollen.","title":"Grosse Datenmengen"},{"location":"big.html#umgang-mit-grossen-datenmengen","text":"Bei der Arbeit mit sehr grossen Datenmengen kann es zu Ressourcen- bzw. Speicherproblemen kommen. Um dem entgegenzuwirken gibt es einige einfache M\u00f6glichkeiten.","title":"Umgang mit grossen Datenmengen"},{"location":"big.html#output-komprimieren","text":"Abfragen im SAS Enterprise Guide k\u00f6nnen um diverse Optionen erg\u00e4nzt werden: Optionen -> Optionen f\u00fcr diese Abfrage -> Ergebnisse Im Feld Optionen: kann SQL-Code eingegeben werden. In diesem Fall compress=yes . Dies f\u00fchrt dazu, dass der Output der Abfrage komprimiert wird und weniger Speicherplatz auf dem SAS-Server in Anspruch nimmt. Zudem sollte die Abfrage so auch schneller durchlaufen.","title":"Output komprimieren"},{"location":"big.html#loschen-mit-proc-datasets","text":"Nicht mehr ben\u00f6tigte Datens\u00e4tze brauchen unn\u00f6tig Speicherplatz im WORK-Verzeichnis und sollten deshalb gel\u00f6scht werden. Zum Beispiel: Wenn mehrere Datens\u00e4tze durch einen Merge zu einem neuen Datensatz zusammengef\u00fcgt werden, k\u00f6nnen nach dem Merge die urspr\u00fcnglichen Datens\u00e4tze gel\u00f6scht werden. proc datasets lib=work; delete dataset1 dataset2 dataset3; run; Dieser Ansatz ist eher f\u00fcr SAS-Projekte mit Programmierung geeignet, kann aber theoretisch auch mit vordefinierten Abfragen und Anwendungsroutinen des SAS Enterprise Guide kombiniert werden. Dazu einfach den Code in ein Programm schreiben, rechter Mausklick auf den zu l\u00f6schenden Datensatz und \u00abVerkn\u00fcpfen mit\u00bb und das Programm mit dem Proc Datasets-Statement ausw\u00e4hlen. WICHTIG: Beim Schliessen des SAS Enterprise Guide werden alle Daten im WORK-Verzeichnis gel\u00f6scht. Das L\u00f6schen mittels Proc Datasets ist also nicht bei jedem noch so kleinen SAS-Projekt n\u00f6tig. Wichtig ist es eher bei sehr grossen Projekten mit vielen Abfragen bzw. Programmen und mit grossen Datens\u00e4tzen.","title":"L\u00f6schen mit PROC DATASETS"},{"location":"big.html#effiziente-sortierung","text":"Das Sortieren von Datens\u00e4tzen kann vor allem bei grossen Datens\u00e4tzen sehr ressourcenintensiv sein. Es gibt zwei Ans\u00e4tze um sowohl Zeit als auch Speicherplatz einzusparen. Das Proc Sort-Statement um die Option TAGSORT erg\u00e4nzen: proc sort data=person tagsort ; by alter; run; Wenn nur ein Subset eines Datensatzes sortiert werden soll, wird das oft in zwei Schritten gemacht: data person_f (where=(geschlecht=\"F\")); set person; run; proc sort data=person_f out=person_f_sorted; by alter; run; Ein Kombinieren dieser beiden Schritte spart sowohl Zeit als auch Speicherplatz: proc sort data=person (where=(geschlecht=\"F\")) out=person_f_sorted; by alter; run;","title":"Effiziente Sortierung"},{"location":"big.html#auswahl-und-filter","text":"Aus jeder Abfrage resultierte ein neuer Datensatz, der im WORK-Verzeichnis gespeichert wird. Je kleiner dieser ist, desto schneller l\u00e4uft die Abfrage durch und desto weniger Speicher wird im WORK-Verzeichnis in Anspruch genommen. Deshalb sind folgende zwei Grunds\u00e4tze wichtig: Auswahl der Variablen: So fr\u00fch wie m\u00f6glich nur noch mit den relevanten Variablen arbeiten. Am besten bereits bei der ersten Abfrage die unn\u00f6tigen Variablen weglassen. Filter setzen: So fr\u00fch wie m\u00f6glich filtern. Wenn f\u00fcr eine Auswertung nur eine bestimmte Personengruppe ben\u00f6tigt wird, sollte am besten gleich in der ersten Abfrage nach dieser gefiltert werden.","title":"Auswahl und Filter"},{"location":"big.html#export-mittels-data-step","text":"Um einen Datensatz aus SAS in ein externes File zu exportieren, wird oft ODS und ein Proc Print-Statement verwendet. Ist der Datensatz allerdings sehr gross, dann kann das extrem lange dauern. In diesem Fall bietet sich unter Umst\u00e4nden ein Export mittels Data Step und PUT-Statement an: data _null_; set table1; file=\"<\u2009Pfad\u2009>\\Dateiname.csv\" encoding=\"UTF-8\" dlm=\";\"; if _n_=1 then put \"Name;Geschlecht;Merkmal;Wert\"; put Name Geschlecht Merkmal Wert; run; dlm : Bestimmt das Trennzeichen zwischen den Datenreihen, in diesem Fall ein Semikolon. if _n_=1 : Der Nachteil dieser Methode ist, dass die Spaltennamen nicht exportiert werden, sondern nur die Daten. Deshalb muss die erste Zeile mit den Spaltennamen manuell hinzugef\u00fcgt werden. Wichtig ist es, die Spaltennamen mit dem korrekten Trennzeichen aneinanderzuh\u00e4ngen und in Anf\u00fchrungszeichen zu setzen. put : Hier werden alle Variablen erfasst, die exportiert werden sollen.","title":"Export mittels Data Step"},{"location":"code.html","text":"N\u00fctzlicher Code Auch beim Arbeiten mit Abfragen und Anwendungsroutinen des SAS Enterprise Guide kommt man teilweise nicht ganz um die Verwendung von Code bzw. Funktionen herum. Oft ist es die einzige oder zumindest die beste M\u00f6glichkeit, auf einfache und schnelle Art und Weise neue Variablen zu generieren. Im Folgenden sind einige n\u00fctzliche Funktionen und Statements zusammengetragen. Sie k\u00f6nnen in einer Abfrage folgendermassen verwendet werden: Neue berechnete Spalte hinzuf\u00fcgen -> Erweiterter Ausdruck put() Mit der put()-Funktion l\u00e4sst sich eine numerische Variable mittels Format in eine Textvariable umwandeln. put(Variable, Format.) Anwendungsbeispiel: Die Personen in einem Datensatz sollen anhand ihres Alters verschiedenen Altersgruppen zugeordnet werden. Anschliessend soll die Anzahl Personen pro Altersgruppe und Geschlecht gez\u00e4hlt werden. Problem: Es reicht nicht, der Variable Alter in der Abfrage ein Format f\u00fcr die Altersgruppen zuzuweisen. Das Format bzw. die Altersgruppe ist zwar im Vordergrund sichtbar, die Variable enth\u00e4lt aber immer noch das exakte Alter. Wird nun die Anzahl Personen nach Geschlecht und Alter gez\u00e4hlt, resultiert \u00fcberall eine 1, auch wenn es bspw. drei Frauen in der Altersgruppe \u00ab20 bis 60\u00bb g\u00e4be. Ein m\u00f6glicher L\u00f6sungsansatz ist es, die numerische Variable Alter in eine Textvariable Altersgruppe umzuwandeln: put(t1.Alter, fmt_alter.) Anschliessend kann die Anzahl Personen nach der Variable Geschlecht und der neuen Variable Altersgruppe gez\u00e4hlt werden. Hinweis: Dieses Problem kann auch mittels CASE Statement gel\u00f6st werden. substr() Mit der substr()-Funktion l\u00e4sst sich ein Teil eines Strings - ein Substring - extrahieren. substr(Variable, Startpunkt, L\u00e4nge) Anwendungsbeispiel: Vom Vornamen der Personen im Datensatz soll jeweils der Anfangsbuchstabe extrahiert und in einer neuen Variable gespeichert werden. Dieser Substring beginnt beim ersten Buchstaben und ist ein Zeichen lang: substr(t1.Name, 1, 1) In einer weiteren Variable sollen die zwei letzten Buchstaben des Vornamens gespeichert werden. Dieser Substring beginnt beim zweitletzten Buchstaben und ist zwei Zeichen lang: substr(t1.Name, length(t1.Name)-1, 2) Schliesslich soll noch der restliche, mittlere Teil des Vornamens in einer separaten Variable gespeichert werden. Dieser Substring beginnt beim zweiten Buchstaben und enth\u00e4lt alle Zeichen ausser das erste und die letzten zwei, umfasst also \u00abGesamte Anzahl - 3\u00bb Zeichen: substr(t1.Name, 2, length(t1.Name)-3) scan() Mit der scan()-Funktion l\u00e4sst sich ein Wort aus einer Reihe von W\u00f6rtern extrahieren, welche mit bestimmten Trennzeichen abgetrennt sind. scan(Variable, ntes Wort [, Trennzeichen]) Nach folgenden Trennzeichen wird automatisch gesucht: Leerzeichen ! $ % & ( ) * + , \u2013 . / ; < | Anwendungsbeispiel: In einem Datensatz ist zu jeder Person der komplette Name erfasst. Nachname und Vorname sind dabei mit Komma abgetrennt. Nun sollen zwei neue Variablen erstellt werden, welche den Vornamen und den Nachnamen enthalten: Vorname: scan(t1.Name, 2) Nachname: scan(t1.Name, 1) Problem: Wenn ein Doppelname enthalten ist, funktioniert dieser Code nicht, da der Bindestrich automatisch als Trennzeichen erkennt wird. In diesem Fall muss der Funktion explizit die Information mitgegeben werden, welches Trennzeichen verwendet werden soll: Vorname: scan(t1.Name, 2, \",\") Nachname: scan(t1.Name, 1, \",\") CASE Statement Mit einem CASE Statement kann eine neue Variable generiert werden, deren Auspr\u00e4gungen von der erf\u00fcllten Bedingung abh\u00e4ngig sind. CASE WHEN Bedingung1 THEN Resultat1 WHEN Bedingung2 THEN Resultat2 WHEN BedingungN THEN ResultatN ELSE Resultat END Anwendungsbeispiel: Die Personen in einem Datensatz sollen anhand ihres Alters verschiedenen Altersgruppen zugeordnet werden. Anschliessend soll die Anzahl Personen pro Altersgruppe und Geschlecht gez\u00e4hlt werden. Dazu wird zuerst mittels CASE-Statement eine neue Variable Altersgruppe generiert: CASE WHEN t1.Alter BETWEEN 0 AND 19 THEN \"Bis 20 Jahre\" WHEN t1.Alter BETWEEN 20 AND 60 THEN \"20 bis 60 Jahre\" WHEN t1.Alter > 60 THEN \"\u00dcber 60 Jahre\" END Anschliessend kann die Anzahl Personen nach der Variable Geschlecht und der neuen Variable Altersgruppe gez\u00e4hlt werden. Hinweis: Dieses Problem kann auch mittels put()-Funktion gel\u00f6st werden.","title":"N\u00fctzlicher Code"},{"location":"code.html#nutzlicher-code","text":"Auch beim Arbeiten mit Abfragen und Anwendungsroutinen des SAS Enterprise Guide kommt man teilweise nicht ganz um die Verwendung von Code bzw. Funktionen herum. Oft ist es die einzige oder zumindest die beste M\u00f6glichkeit, auf einfache und schnelle Art und Weise neue Variablen zu generieren. Im Folgenden sind einige n\u00fctzliche Funktionen und Statements zusammengetragen. Sie k\u00f6nnen in einer Abfrage folgendermassen verwendet werden: Neue berechnete Spalte hinzuf\u00fcgen -> Erweiterter Ausdruck","title":"N\u00fctzlicher Code"},{"location":"code.html#put","text":"Mit der put()-Funktion l\u00e4sst sich eine numerische Variable mittels Format in eine Textvariable umwandeln. put(Variable, Format.) Anwendungsbeispiel: Die Personen in einem Datensatz sollen anhand ihres Alters verschiedenen Altersgruppen zugeordnet werden. Anschliessend soll die Anzahl Personen pro Altersgruppe und Geschlecht gez\u00e4hlt werden. Problem: Es reicht nicht, der Variable Alter in der Abfrage ein Format f\u00fcr die Altersgruppen zuzuweisen. Das Format bzw. die Altersgruppe ist zwar im Vordergrund sichtbar, die Variable enth\u00e4lt aber immer noch das exakte Alter. Wird nun die Anzahl Personen nach Geschlecht und Alter gez\u00e4hlt, resultiert \u00fcberall eine 1, auch wenn es bspw. drei Frauen in der Altersgruppe \u00ab20 bis 60\u00bb g\u00e4be. Ein m\u00f6glicher L\u00f6sungsansatz ist es, die numerische Variable Alter in eine Textvariable Altersgruppe umzuwandeln: put(t1.Alter, fmt_alter.) Anschliessend kann die Anzahl Personen nach der Variable Geschlecht und der neuen Variable Altersgruppe gez\u00e4hlt werden. Hinweis: Dieses Problem kann auch mittels CASE Statement gel\u00f6st werden.","title":"put()"},{"location":"code.html#substr","text":"Mit der substr()-Funktion l\u00e4sst sich ein Teil eines Strings - ein Substring - extrahieren. substr(Variable, Startpunkt, L\u00e4nge) Anwendungsbeispiel: Vom Vornamen der Personen im Datensatz soll jeweils der Anfangsbuchstabe extrahiert und in einer neuen Variable gespeichert werden. Dieser Substring beginnt beim ersten Buchstaben und ist ein Zeichen lang: substr(t1.Name, 1, 1) In einer weiteren Variable sollen die zwei letzten Buchstaben des Vornamens gespeichert werden. Dieser Substring beginnt beim zweitletzten Buchstaben und ist zwei Zeichen lang: substr(t1.Name, length(t1.Name)-1, 2) Schliesslich soll noch der restliche, mittlere Teil des Vornamens in einer separaten Variable gespeichert werden. Dieser Substring beginnt beim zweiten Buchstaben und enth\u00e4lt alle Zeichen ausser das erste und die letzten zwei, umfasst also \u00abGesamte Anzahl - 3\u00bb Zeichen: substr(t1.Name, 2, length(t1.Name)-3)","title":"substr()"},{"location":"code.html#scan","text":"Mit der scan()-Funktion l\u00e4sst sich ein Wort aus einer Reihe von W\u00f6rtern extrahieren, welche mit bestimmten Trennzeichen abgetrennt sind. scan(Variable, ntes Wort [, Trennzeichen]) Nach folgenden Trennzeichen wird automatisch gesucht: Leerzeichen ! $ % & ( ) * + , \u2013 . / ; < | Anwendungsbeispiel: In einem Datensatz ist zu jeder Person der komplette Name erfasst. Nachname und Vorname sind dabei mit Komma abgetrennt. Nun sollen zwei neue Variablen erstellt werden, welche den Vornamen und den Nachnamen enthalten: Vorname: scan(t1.Name, 2) Nachname: scan(t1.Name, 1) Problem: Wenn ein Doppelname enthalten ist, funktioniert dieser Code nicht, da der Bindestrich automatisch als Trennzeichen erkennt wird. In diesem Fall muss der Funktion explizit die Information mitgegeben werden, welches Trennzeichen verwendet werden soll: Vorname: scan(t1.Name, 2, \",\") Nachname: scan(t1.Name, 1, \",\")","title":"scan()"},{"location":"code.html#case-statement","text":"Mit einem CASE Statement kann eine neue Variable generiert werden, deren Auspr\u00e4gungen von der erf\u00fcllten Bedingung abh\u00e4ngig sind. CASE WHEN Bedingung1 THEN Resultat1 WHEN Bedingung2 THEN Resultat2 WHEN BedingungN THEN ResultatN ELSE Resultat END Anwendungsbeispiel: Die Personen in einem Datensatz sollen anhand ihres Alters verschiedenen Altersgruppen zugeordnet werden. Anschliessend soll die Anzahl Personen pro Altersgruppe und Geschlecht gez\u00e4hlt werden. Dazu wird zuerst mittels CASE-Statement eine neue Variable Altersgruppe generiert: CASE WHEN t1.Alter BETWEEN 0 AND 19 THEN \"Bis 20 Jahre\" WHEN t1.Alter BETWEEN 20 AND 60 THEN \"20 bis 60 Jahre\" WHEN t1.Alter > 60 THEN \"\u00dcber 60 Jahre\" END Anschliessend kann die Anzahl Personen nach der Variable Geschlecht und der neuen Variable Altersgruppe gez\u00e4hlt werden. Hinweis: Dieses Problem kann auch mittels put()-Funktion gel\u00f6st werden.","title":"CASE Statement"},{"location":"export.html","text":"Daten exportieren An Microsoft Excel senden Der Output einer Anwendungsroutine (bspw. Zusammenfassungstabelle) kann folgendermassen in Excel exportiert werden: Problem: Ist im Enterprise Guide unter \u00abExtras -> Optionen -> Ergebnisse -> Allgemein\u00bb das Ergebnisformat HTML ausgew\u00e4hlt, dann wird der entsprechende Output mit einem Punkt als Dezimaltrennzeichen exportiert. In Excel kann damit dann nicht weitergerechnet werden und im schlimmsten Fall wird die Zahl sogar als Datum erkannt. Es gibt mehrere M\u00f6glichkeiten, dieses Problem zu umgehen: Als Ergebnisformat \u00abSAS Report\u00bb anstatt \u00abHTML\u00bb ausw\u00e4hlen. Wird der Output eines SAS Reports mittels \u00abAn Microsoft Excel senden\u00bb exportiert, werden die Dezimaltrennzeichen korrekt angezeigt. Als Ergebnisformat zus\u00e4tzlich \u00abExcel\u00bb ausw\u00e4hlen. So wird beim Ausf\u00fchren der Anwendungsroutine direkt ein Excel-File generiert, das direkt aus SAS mittels Doppelklick ge\u00f6ffnet werden kann. F\u00fcr die numerische Variable das Format NUMXw.d ausw\u00e4hlen. Bei einer Zusammenfassungstabelle wird das folgendermassen gemacht: Rechtsklick auf die Statistik (bspw. Sum) -> Datenwerteigenschaften -> Ausgabeformat -> Numerisch -> NUMXw.d. Zum Exportieren entweder ODS Excel oder Proc Export (Eintrag dazu folgt) verwenden. ODS Excel ODS Excel bietet die M\u00f6glichkeit, den Output von SAS-Prozeduren (bspw. Proc Report, Proc Tabulate oder Proc Print) direkt in ein Excel-File zu schreiben. ods excel file=\"<\u2009Pfad\u2009>\\Dateiname.xlsx\" [diverse Optionen]; [proc print, proc report, proc tabulate, o.\u00e4.] ods csv close; Anwendungsbeispiel 1: Mit ODS Excel l\u00e4sst sich die Struktur einer Webtabelle nachbilden, sodass der generierte Export nur noch mittels Copy-Paste in die Webtabelle eingef\u00fcgt werden muss. ods excel style=journal file=\"<Pfad>/SAS-Export T99_9_99.xlsx\" options(embedded_titles='yes' sheet_interval='bygroup' sheet_name='#byval1'); title \"Anzahl Personen nach Altersgruppe\"; proc tabulate data=personen; by Jahr; [hier kommt Code] run; ods excel close; style=journal : Bestimmt das Design, in dem der Excel-Export daherkommt. F\u00fcr eine \u00dcbersicht \u00fcber alle ODS-Styles siehe hier . embedded_titles='yes' bzw. title : F\u00fcr die exportierte(n) Tabelle(n) kann ein Titel festgelegt werden. Dasselbe funktioniert auch mit Fussnoten ( embedded_footnotes='yes' bzw. footnote ). sheet_interval='bygroup' : F\u00fcr jede Auspr\u00e4gung der by-Variable wird ein neues Tabellenblatt angelegt, in diesem Beispiel also f\u00fcr jedes Jahr. sheet_name='#byval1' : Die Tabellenbl\u00e4tter werden entsprechend der Auspr\u00e4gungen der by-Variable benannt, in diesem Beispiel also \u00ab2021\u00bb , \u00ab2020\u00bb , \u00ab2019\u00bb , etc. proc tabulate : Hier kann bspw. der Code einer Zusammenfassungstabelle eingef\u00fcgt werden: Doppelklick auf Symbol der Zusammenfassungstabelle -> Code -> Kopieren von \u00abPROC TABULATE\u00bb bis \u00abRUN;\u00bb. Anwendungsbeispiel 2: Eine leicht modifizierte Form - ODS CSV - findet bei der Produktion von tsv-Files f\u00fcr die interaktiven Indikatoren Anwendung. ods csv file = \"<Pfad>\\9999.tsv\" encoding='utf-8' options(delimiter=\"09\"x); proc tabulate data=personen; [hier kommt Code] run; ods csv close; encoding='utf-8' : Sorgt u. a. daf\u00fcr, dass die Umlaute richtig dargestellt werden. delimiter=\"09\"x : Erzeugt ein Tabulator-getrenntes Dokument. proc tabulate : Hier kann bspw. der Code einer Zusammenfassungstabelle eingef\u00fcgt werden: Doppelklick auf Symbol der Zusammenfassungstabelle -> Code -> Kopieren von \u00abPROC TABULATE\u00bb bis \u00abRUN;\u00bb. Es gibt zahlreiche weitere M\u00f6glichkeiten, den Output von ODS Excel zu steuern bzw. anzupassen. F\u00fcr eine vollst\u00e4ndige \u00dcbersicht siehe hier . Weitere Informationen zu ODS Excel finden sich auch auf der Seite zur Server-Migration . Wenn der Export mit ODS Excel sehr lange dauert, ist unter Umst\u00e4nden ein Export mittels Data Step und PUT-Statement eine Option.","title":"Daten exportieren"},{"location":"export.html#daten-exportieren","text":"","title":"Daten exportieren"},{"location":"export.html#an-microsoft-excel-senden","text":"Der Output einer Anwendungsroutine (bspw. Zusammenfassungstabelle) kann folgendermassen in Excel exportiert werden: Problem: Ist im Enterprise Guide unter \u00abExtras -> Optionen -> Ergebnisse -> Allgemein\u00bb das Ergebnisformat HTML ausgew\u00e4hlt, dann wird der entsprechende Output mit einem Punkt als Dezimaltrennzeichen exportiert. In Excel kann damit dann nicht weitergerechnet werden und im schlimmsten Fall wird die Zahl sogar als Datum erkannt. Es gibt mehrere M\u00f6glichkeiten, dieses Problem zu umgehen: Als Ergebnisformat \u00abSAS Report\u00bb anstatt \u00abHTML\u00bb ausw\u00e4hlen. Wird der Output eines SAS Reports mittels \u00abAn Microsoft Excel senden\u00bb exportiert, werden die Dezimaltrennzeichen korrekt angezeigt. Als Ergebnisformat zus\u00e4tzlich \u00abExcel\u00bb ausw\u00e4hlen. So wird beim Ausf\u00fchren der Anwendungsroutine direkt ein Excel-File generiert, das direkt aus SAS mittels Doppelklick ge\u00f6ffnet werden kann. F\u00fcr die numerische Variable das Format NUMXw.d ausw\u00e4hlen. Bei einer Zusammenfassungstabelle wird das folgendermassen gemacht: Rechtsklick auf die Statistik (bspw. Sum) -> Datenwerteigenschaften -> Ausgabeformat -> Numerisch -> NUMXw.d. Zum Exportieren entweder ODS Excel oder Proc Export (Eintrag dazu folgt) verwenden.","title":"An Microsoft Excel senden"},{"location":"export.html#ods-excel","text":"ODS Excel bietet die M\u00f6glichkeit, den Output von SAS-Prozeduren (bspw. Proc Report, Proc Tabulate oder Proc Print) direkt in ein Excel-File zu schreiben. ods excel file=\"<\u2009Pfad\u2009>\\Dateiname.xlsx\" [diverse Optionen]; [proc print, proc report, proc tabulate, o.\u00e4.] ods csv close; Anwendungsbeispiel 1: Mit ODS Excel l\u00e4sst sich die Struktur einer Webtabelle nachbilden, sodass der generierte Export nur noch mittels Copy-Paste in die Webtabelle eingef\u00fcgt werden muss. ods excel style=journal file=\"<Pfad>/SAS-Export T99_9_99.xlsx\" options(embedded_titles='yes' sheet_interval='bygroup' sheet_name='#byval1'); title \"Anzahl Personen nach Altersgruppe\"; proc tabulate data=personen; by Jahr; [hier kommt Code] run; ods excel close; style=journal : Bestimmt das Design, in dem der Excel-Export daherkommt. F\u00fcr eine \u00dcbersicht \u00fcber alle ODS-Styles siehe hier . embedded_titles='yes' bzw. title : F\u00fcr die exportierte(n) Tabelle(n) kann ein Titel festgelegt werden. Dasselbe funktioniert auch mit Fussnoten ( embedded_footnotes='yes' bzw. footnote ). sheet_interval='bygroup' : F\u00fcr jede Auspr\u00e4gung der by-Variable wird ein neues Tabellenblatt angelegt, in diesem Beispiel also f\u00fcr jedes Jahr. sheet_name='#byval1' : Die Tabellenbl\u00e4tter werden entsprechend der Auspr\u00e4gungen der by-Variable benannt, in diesem Beispiel also \u00ab2021\u00bb , \u00ab2020\u00bb , \u00ab2019\u00bb , etc. proc tabulate : Hier kann bspw. der Code einer Zusammenfassungstabelle eingef\u00fcgt werden: Doppelklick auf Symbol der Zusammenfassungstabelle -> Code -> Kopieren von \u00abPROC TABULATE\u00bb bis \u00abRUN;\u00bb. Anwendungsbeispiel 2: Eine leicht modifizierte Form - ODS CSV - findet bei der Produktion von tsv-Files f\u00fcr die interaktiven Indikatoren Anwendung. ods csv file = \"<Pfad>\\9999.tsv\" encoding='utf-8' options(delimiter=\"09\"x); proc tabulate data=personen; [hier kommt Code] run; ods csv close; encoding='utf-8' : Sorgt u. a. daf\u00fcr, dass die Umlaute richtig dargestellt werden. delimiter=\"09\"x : Erzeugt ein Tabulator-getrenntes Dokument. proc tabulate : Hier kann bspw. der Code einer Zusammenfassungstabelle eingef\u00fcgt werden: Doppelklick auf Symbol der Zusammenfassungstabelle -> Code -> Kopieren von \u00abPROC TABULATE\u00bb bis \u00abRUN;\u00bb. Es gibt zahlreiche weitere M\u00f6glichkeiten, den Output von ODS Excel zu steuern bzw. anzupassen. F\u00fcr eine vollst\u00e4ndige \u00dcbersicht siehe hier . Weitere Informationen zu ODS Excel finden sich auch auf der Seite zur Server-Migration . Wenn der Export mit ODS Excel sehr lange dauert, ist unter Umst\u00e4nden ein Export mittels Data Step und PUT-Statement eine Option.","title":"ODS Excel"},{"location":"formate.html","text":"Benutzerdefinierte Formate Syntax SAS bietet die M\u00f6glichkeit, eigene Formate zu schreiben. Formate werden mittels PROC FORMAT-Statement in folgender Form erstellt: proc format; value < Formatname > [...hier wird das Format definiert...]; run; Bei der Namensgebung gibt es einige Konventionen zu ber\u00fccksichtigen: Formatnamen d\u00fcrfen nicht mit einer Zahl enden. Bei alphanumerischen Formaten muss der Name mit einem Dollarzeichen ($) beginnen. Der Formatname darf nich l\u00e4nger als 32 Zeichen sein. Hinweis: Innerhalb eines PROC FORMAT k\u00f6nnen mehrere VALUE-Statements bzw. mehrere Formate definiert werden. Numerisch oder alphanumerisch Formate k\u00f6nnen numerisch oder alphanumerisch sein: Wenn ein Datensatz nur codierte Werte enth\u00e4lt, dann wird ein numerisches Format verwendet, um den Codes eine Bezeichnung zuzuordnen, bspw. bei der Variable Geschlecht den Codes 1 und 2 die Bezeichnungen \u00abm\u00e4nnlich\u00bb und \u00abweiblich\u00bb: proc format; value fmt_gesl 1=\"m\u00e4nnlich\" 2=\"weiblich\"; run; Wird das Format fmt_gesl auf die Variable Geschlecht angewendet ergibt sich folgende Transformation: \u2002\u2002\u2002 \u2192 \u2002\u2002 Mit einem alphanumerischen Format werden den Auspr\u00e4gungen einer Textvariable neue Bezeichnungen zugewiesen, bspw. dem Wohnort der entsprechende Kanton: proc format; value $fmt_wohnort \"Basel\",\"Riehen\"=\"Basel-Stadt\" \"Z\u00fcrich\"=\"Z\u00fcrich\"; run; Wird das Format $fmt_wohnort auf die Variable Wohnort angewendet ergibt sich folgende Transformation: \u2002\u2002\u2002 \u2192 \u2002\u2002 Anwenden von benutzerdefinierten Formaten Es gibt verschiedene M\u00f6glichkeiten, die erzeugten Formate einer Variable zuzuweisen: Abfrage erstellen: Doppelklick auf die entsprechende Variable -> \u00c4ndern -> Benutzerdefiniert Zusammenfassungstabelle: Ensprechende Variable anw\u00e4hlen -> \u00dcberschriftformat -> Benutzerdefiniert Programmcode: Formate k\u00f6nnen direkt in Prozeduren (PROC TABULATE, PROC PRINT, PROC REPORT)... proc tabulate data=work.person; var groesse; class geschlecht / order=unformatted missing; format Geschlecht fmt_gesl. Wohnort $fmt_wohnort.; table geschlecht, groesse*mean; run; ...oder auch in einem DATA STEP verwendet werden. data person_fmt; set person; format Geschlecht fmt_gesl. Wohnort $fmt_wohnort.; run; Hinweis: Um das Format im Code zu referenzieren wird der Formatname gefolgt von einem Punkt verwendet. Gruppieren mittels Format Mit Formaten kann nicht nur einzelnen Werten eine Bezeichnung zugeordnet werden, es k\u00f6nnen auch mehrere Werte zu einer Gruppe zusammengefasst werden. Anwendungsbeispiel: Anhand der Variable Alter sollen Altersgruppen gebildet werden. proc format; value fmt_alter 0-19 = \"bis 20 Jahre\" 20-60 = \"20 bis 60 Jahre\" 61-high = \"\u00fcber 60 Jahre\"; run; Wichtig: F\u00fcr gewisse Anwendungen (bspw. Summieren nach Altersgruppe in einer Abfrage) reicht es nicht, der numerischen Variable einfach das Format fmt_alter zuzuweisen, sondern es muss eine neue Variable Altersgruppe generiert werden. Mehr dazu hier . Sortieren mittels Format Beim Arbeiten mit Formaten und Auswertungen mittels Zusammenfassungstabelle ist manchmal eine bestimmte Reihenfolge erforderlich, bspw. weil diese f\u00fcr einen tsv-Export ben\u00f6tigt wird. Mit der Option notsorted kann die Reihenfolge aus dem PROC FORMAT-Statement erzwungen werden. proc format; value fmt_alter (notsorted) 61-high = \"\u00fcber 60 Jahre\" 20-60 = \"20 bis 60 Jahre\" 0-19 = \"bis 20 Jahre\"; run; Damit es mit der Reihenfolge klappt, sind in der Zusammenfassungstabelle einige Einstellungen n\u00f6tig: Sortieren nach : Hier Dateireihenfolge ausw\u00e4hlen. Ettiketten aus Format vorab \u00fcbernehmen : Auf Wahr setzen, damit das Format vor dem Ausf\u00fchren der Zusammenfassungstabelle geladen wird. \u00dcberschriftformat : Hier das entsprechende benutzerdefinierte Format ausw\u00e4hlen, in diesem Beispiel fmt_alter . So kann die Anzahl Personen pro Altersgruppe nach Geschlecht bestimmt und das Ergebnis nach absteigender Altersgruppe sortiert werden: \u2002\u2002\u2002 \u2192 \u2002\u2002 Totale und Subtotale mittels Format Mit Formaten k\u00f6nnen auch Totale oder Subtotale gebildet werden. In diesem Fall werden den Werten mehrere Labels zugeordnet, weshalb zus\u00e4tzlich zur Option notsorted auch die Option multilabel verwendet werden muss. Bspw. geh\u00f6ren die 13-J\u00e4hrigen dann zur Gruppe unter 15 Jahre und Total unter 65 Jahre . proc format; value fmt_alter (multilabel notsorted) 0-14 = \"unter 15 Jahre\" 15-24 =\"15 bis 24 Jahre\" 25-44 = \"25 bis 44 Jahre\" 45-64 = \"45 bis 64 Jahre\" 0-64 = \"Total unter 65 Jahre\" 65-high = \"65 Jahre und mehr\" 0-high = \"Total\"; run; Zus\u00e4tzlich zu den im vorherigen Abschnitt beschriebenen Einstellungen muss Folgendes eingestellt werden: Formate mit mehreren Etiketten : Auf Aktiviert setzen. So k\u00f6nnen das Subtotal f\u00fcr die unter 65-J\u00e4hrigen und das Total aller Personen hinzugef\u00fcgt werden: \u2002\u2002\u2002 \u2192","title":"Benutzerdefinierte Formate"},{"location":"formate.html#benutzerdefinierte-formate","text":"","title":"Benutzerdefinierte Formate"},{"location":"formate.html#syntax","text":"SAS bietet die M\u00f6glichkeit, eigene Formate zu schreiben. Formate werden mittels PROC FORMAT-Statement in folgender Form erstellt: proc format; value < Formatname > [...hier wird das Format definiert...]; run; Bei der Namensgebung gibt es einige Konventionen zu ber\u00fccksichtigen: Formatnamen d\u00fcrfen nicht mit einer Zahl enden. Bei alphanumerischen Formaten muss der Name mit einem Dollarzeichen ($) beginnen. Der Formatname darf nich l\u00e4nger als 32 Zeichen sein. Hinweis: Innerhalb eines PROC FORMAT k\u00f6nnen mehrere VALUE-Statements bzw. mehrere Formate definiert werden.","title":"Syntax"},{"location":"formate.html#numerisch-oder-alphanumerisch","text":"Formate k\u00f6nnen numerisch oder alphanumerisch sein: Wenn ein Datensatz nur codierte Werte enth\u00e4lt, dann wird ein numerisches Format verwendet, um den Codes eine Bezeichnung zuzuordnen, bspw. bei der Variable Geschlecht den Codes 1 und 2 die Bezeichnungen \u00abm\u00e4nnlich\u00bb und \u00abweiblich\u00bb: proc format; value fmt_gesl 1=\"m\u00e4nnlich\" 2=\"weiblich\"; run; Wird das Format fmt_gesl auf die Variable Geschlecht angewendet ergibt sich folgende Transformation: \u2002\u2002\u2002 \u2192 \u2002\u2002 Mit einem alphanumerischen Format werden den Auspr\u00e4gungen einer Textvariable neue Bezeichnungen zugewiesen, bspw. dem Wohnort der entsprechende Kanton: proc format; value $fmt_wohnort \"Basel\",\"Riehen\"=\"Basel-Stadt\" \"Z\u00fcrich\"=\"Z\u00fcrich\"; run; Wird das Format $fmt_wohnort auf die Variable Wohnort angewendet ergibt sich folgende Transformation: \u2002\u2002\u2002 \u2192","title":"Numerisch oder alphanumerisch"},{"location":"formate.html#anwenden-von-benutzerdefinierten-formaten","text":"Es gibt verschiedene M\u00f6glichkeiten, die erzeugten Formate einer Variable zuzuweisen: Abfrage erstellen: Doppelklick auf die entsprechende Variable -> \u00c4ndern -> Benutzerdefiniert Zusammenfassungstabelle: Ensprechende Variable anw\u00e4hlen -> \u00dcberschriftformat -> Benutzerdefiniert Programmcode: Formate k\u00f6nnen direkt in Prozeduren (PROC TABULATE, PROC PRINT, PROC REPORT)... proc tabulate data=work.person; var groesse; class geschlecht / order=unformatted missing; format Geschlecht fmt_gesl. Wohnort $fmt_wohnort.; table geschlecht, groesse*mean; run; ...oder auch in einem DATA STEP verwendet werden. data person_fmt; set person; format Geschlecht fmt_gesl. Wohnort $fmt_wohnort.; run; Hinweis: Um das Format im Code zu referenzieren wird der Formatname gefolgt von einem Punkt verwendet.","title":"Anwenden von benutzerdefinierten Formaten"},{"location":"formate.html#gruppieren-mittels-format","text":"Mit Formaten kann nicht nur einzelnen Werten eine Bezeichnung zugeordnet werden, es k\u00f6nnen auch mehrere Werte zu einer Gruppe zusammengefasst werden. Anwendungsbeispiel: Anhand der Variable Alter sollen Altersgruppen gebildet werden. proc format; value fmt_alter 0-19 = \"bis 20 Jahre\" 20-60 = \"20 bis 60 Jahre\" 61-high = \"\u00fcber 60 Jahre\"; run; Wichtig: F\u00fcr gewisse Anwendungen (bspw. Summieren nach Altersgruppe in einer Abfrage) reicht es nicht, der numerischen Variable einfach das Format fmt_alter zuzuweisen, sondern es muss eine neue Variable Altersgruppe generiert werden. Mehr dazu hier .","title":"Gruppieren mittels Format"},{"location":"formate.html#sortieren-mittels-format","text":"Beim Arbeiten mit Formaten und Auswertungen mittels Zusammenfassungstabelle ist manchmal eine bestimmte Reihenfolge erforderlich, bspw. weil diese f\u00fcr einen tsv-Export ben\u00f6tigt wird. Mit der Option notsorted kann die Reihenfolge aus dem PROC FORMAT-Statement erzwungen werden. proc format; value fmt_alter (notsorted) 61-high = \"\u00fcber 60 Jahre\" 20-60 = \"20 bis 60 Jahre\" 0-19 = \"bis 20 Jahre\"; run; Damit es mit der Reihenfolge klappt, sind in der Zusammenfassungstabelle einige Einstellungen n\u00f6tig: Sortieren nach : Hier Dateireihenfolge ausw\u00e4hlen. Ettiketten aus Format vorab \u00fcbernehmen : Auf Wahr setzen, damit das Format vor dem Ausf\u00fchren der Zusammenfassungstabelle geladen wird. \u00dcberschriftformat : Hier das entsprechende benutzerdefinierte Format ausw\u00e4hlen, in diesem Beispiel fmt_alter . So kann die Anzahl Personen pro Altersgruppe nach Geschlecht bestimmt und das Ergebnis nach absteigender Altersgruppe sortiert werden: \u2002\u2002\u2002 \u2192","title":"Sortieren mittels Format"},{"location":"formate.html#totale-und-subtotale-mittels-format","text":"Mit Formaten k\u00f6nnen auch Totale oder Subtotale gebildet werden. In diesem Fall werden den Werten mehrere Labels zugeordnet, weshalb zus\u00e4tzlich zur Option notsorted auch die Option multilabel verwendet werden muss. Bspw. geh\u00f6ren die 13-J\u00e4hrigen dann zur Gruppe unter 15 Jahre und Total unter 65 Jahre . proc format; value fmt_alter (multilabel notsorted) 0-14 = \"unter 15 Jahre\" 15-24 =\"15 bis 24 Jahre\" 25-44 = \"25 bis 44 Jahre\" 45-64 = \"45 bis 64 Jahre\" 0-64 = \"Total unter 65 Jahre\" 65-high = \"65 Jahre und mehr\" 0-high = \"Total\"; run; Zus\u00e4tzlich zu den im vorherigen Abschnitt beschriebenen Einstellungen muss Folgendes eingestellt werden: Formate mit mehreren Etiketten : Auf Aktiviert setzen. So k\u00f6nnen das Subtotal f\u00fcr die unter 65-J\u00e4hrigen und das Total aller Personen hinzugef\u00fcgt werden: \u2002\u2002\u2002 \u2192","title":"Totale und Subtotale mittels Format"},{"location":"merge.html","text":"Datens\u00e4tze verbinden Datensatz anh\u00e4ngen Beispiel: Die Gr\u00f6ssenangaben von Frauen und M\u00e4nnern sind in zwei separaten Datens\u00e4tzen erfasst. Diese beiden Datens\u00e4tze sollen zu einem Datensatz zusammengefasst werden, der die Daten f\u00fcr beide Geschlechter enth\u00e4lt. Anwendungsroutine Tabelle anh\u00e4ngen F\u00fcr diesen L\u00f6sungsansatz wird einer der beiden Datens\u00e4tze angew\u00e4hlt (einfacher Mausklick) und unter \u00abAnwendungsroutinen -> Durchsuchen -> Daten\u00bb die Anwendungsroutine Tabelle anh\u00e4ngen ausgew\u00e4hlt. Im sich \u00f6ffnenden Fenster auf Tabelle hinzuf\u00fcgen klicken und den Datensatz ausw\u00e4hlen, der angeh\u00e4ngt werden soll, in diesem Fall \u00abWEIBLICH\u00bb. \u2002\u2002\u2002 \u2192 \u2002\u2002 Unter Ergebnisse kann ein Name f\u00fcr den neuen Datensatz gew\u00e4hlt werden, in diesem Fall \u00abALLE_PERSONEN\u00bb: Dann auf Ausf\u00fchren klicken um die Tabelle anzuh\u00e4ngen und den neuen Datensatz zu generieren: DATA STEP Die einfachste M\u00f6glichkeit, einen Datensatz an einen anderen anzuh\u00e4ngen, ist ein DATA STEP. Folgender Code h\u00e4ngt die Datens\u00e4tze \u00abMAENNLICH\u00bb und \u00abWEIBLICH\u00bb untereinander und speichert das Ergebnis in einem neuen Datensatz \u00abALLE_PERSONEN\u00bb: data alle_personen; set maennlich weiblich; run; PROC APPEND Eine weitere M\u00f6glichkeit, mittels Programmieren einen Datensatz an einen anderen anzuh\u00e4ngen, ist ein PROC APPEND-Statement. Folgender Code h\u00e4ngt an den Datensatz \u00abMAENNLICH\u00bb den Datensatz \u00abWEIBLICH\u00bb an und \u00fcberschreibt mit dem Ergebnis den urpspr\u00fcnglichen Datensatz \u00abMAENNLICH\u00bb. proc append base=maennlich data=weiblich; run; Unterschiede zwischen den L\u00f6sungsans\u00e4tzen Die verschiedenen L\u00f6sungsans\u00e4tze unterscheiden sich teilweise voneinander. Sehen wir uns an, was passiert, wenn die Variablennamen in den beiden Datens\u00e4tzen nicht identisch geschrieben sind (bspw. Groesse und Gr\u00f6sse): Sowohl die Anwendungsroutine Tabelle anh\u00e4ngen als auch der DATA STEP f\u00fchren zu folgendem Ergebnis: Beim PROC APPEND -Statement hingegen werden die Datens\u00e4tze nicht verbunden und es resultiert stattdessen eine Fehlermeldung: Soll der Append trotzdem durchgef\u00fchrt werden, kann dies mit der Option force erreicht werden: proc append base=maennlich data=weiblich force; run; So werden die Datens\u00e4tze trotzdem aneinandergeh\u00e4ngt. Allerdings werden nur Werte vom Datensatz \u00abWEIBLICH\u00bb angeh\u00e4ngt, wenn die Variablennamen auch im Datensatz \u00abMAENNLICH\u00bb vorkommen: Join mittels Abfrage Beispiel: Das Gewicht und die Gr\u00f6sse der Zielpersonen ist in zwei separaten Datens\u00e4tzen erfasst. Nun soll ein neuer Datensatz erstellt werden, der beide Angaben enth\u00e4lt. Dazu wird mittels rechtem Mausklick auf einen der beiden Datens\u00e4tze und Abfrage erstellen eine Abfrage erstellt. Mit Hinzuf\u00fcgen wird der zweite Datensatz erg\u00e4nzt. Nun k\u00f6nnen die gew\u00fcnschten Variablen gew\u00e4hlt werden bzw. ins Fenster Daten ausw\u00e4hlen gezogen werden. Hier die Variablen Name und Alter nur einmal ausw\u00e4hlen (bspw. aus dem Datensatz t1). Danach muss unter Tabellen joinen definiert werden, anhand welcher Variablen der Join durchgef\u00fchrt werden und um welche Art von Join (Inner Join, Left Join, Right Join etc.) es sich handeln soll. Es wird automatisch ein Join \u00fcber die Variable Name vorgeschlagen. Da der Name \u00abSandra\u00bb zweimal vorkommt, w\u00e4re ein Join anhand des Namens nicht eindeutig. Deshalb wird der Join zus\u00e4tzlich \u00fcber die Variable Alter ausgef\u00fchrt. Dazu auf die Variable Alter im linken K\u00e4stchen klicken (und halten) und den Cursor r\u00fcber zur Variable Alter im rechten K\u00e4stchen ziehen und loslassen. Die Art des Joins spielt in diesem Beispiel keine Rolle, da in beiden Datens\u00e4tze die gleichen Zielpersonen drin sind und es keine fehlenden Eintr\u00e4ge gibt. Im n\u00e4chsten Abschnitt wird n\u00e4her auf den Unterschied zwischen den verschiedenen Join-Typen eingegangen. Es resultiert folgender Datensatz: Verschiedene Join-Typen Inner Join Der neu erzeugte Datensatz enth\u00e4lt nur die Beobachtungen, welche in beiden Ausgangsdatens\u00e4tzen vorkommen. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193 Left Join Der neu erzeugte Datensatz enth\u00e4lt nur die Beobachtungen, welche im ersten Ausgangsdatensatz vorkommen. Diejenigen Beobachtungen, welche im zweiten Ausgangsdatensatz nicht vorkommen, weisen f\u00fcr die Variable Gr\u00f6sse einen fehlenden Wert auf. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193 Right Join Der neu erzeugte Datensatz enth\u00e4lt nur die Beobachtungen, welche im zweiten Ausgangsdatensatz vorkommen. Diejenigen Beobachtungen, welche im ersten Ausgangsdatensatz nicht vorkommen, weisen f\u00fcr die Variable Gewicht einen fehlenden Wert auf. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193 Full Outer Join Der neu erzeugte Datensatz enth\u00e4lt alle Beobachtungen, die in einem der beiden Ausgangsdatens\u00e4tze vorkommen. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193 Hinweis: Bei den anderen Join-Arten reicht es, die Variablen Name und Alter aus einem der beiden Datens\u00e4tze t1 oder t2 auszuw\u00e4hlen. Beim Full Outer Join funktioniert das nicht. Werden die Variablen aus t1 genommen, dann resultieren fehlende Werte bei derjenigen Beobachtung, die nur in t2 vorkommt und umgekehrt. Um sicherzugehen, dass die Variablen Name und Alter keine fehlenden Werte aufweisen, braucht es einen kleinen Umweg \u00fcber die COALESCE-Funktion bzw. \u00abNeue berechnete Spalte hinzuf\u00fcgen -> Erweiterter Ausdruck\u00bb:","title":"Datens\u00e4tze verbinden"},{"location":"merge.html#datensatze-verbinden","text":"","title":"Datens\u00e4tze verbinden"},{"location":"merge.html#datensatz-anhangen","text":"Beispiel: Die Gr\u00f6ssenangaben von Frauen und M\u00e4nnern sind in zwei separaten Datens\u00e4tzen erfasst. Diese beiden Datens\u00e4tze sollen zu einem Datensatz zusammengefasst werden, der die Daten f\u00fcr beide Geschlechter enth\u00e4lt.","title":"Datensatz anh\u00e4ngen"},{"location":"merge.html#anwendungsroutine-tabelle-anhangen","text":"F\u00fcr diesen L\u00f6sungsansatz wird einer der beiden Datens\u00e4tze angew\u00e4hlt (einfacher Mausklick) und unter \u00abAnwendungsroutinen -> Durchsuchen -> Daten\u00bb die Anwendungsroutine Tabelle anh\u00e4ngen ausgew\u00e4hlt. Im sich \u00f6ffnenden Fenster auf Tabelle hinzuf\u00fcgen klicken und den Datensatz ausw\u00e4hlen, der angeh\u00e4ngt werden soll, in diesem Fall \u00abWEIBLICH\u00bb. \u2002\u2002\u2002 \u2192 \u2002\u2002 Unter Ergebnisse kann ein Name f\u00fcr den neuen Datensatz gew\u00e4hlt werden, in diesem Fall \u00abALLE_PERSONEN\u00bb: Dann auf Ausf\u00fchren klicken um die Tabelle anzuh\u00e4ngen und den neuen Datensatz zu generieren:","title":"Anwendungsroutine Tabelle anh\u00e4ngen"},{"location":"merge.html#data-step","text":"Die einfachste M\u00f6glichkeit, einen Datensatz an einen anderen anzuh\u00e4ngen, ist ein DATA STEP. Folgender Code h\u00e4ngt die Datens\u00e4tze \u00abMAENNLICH\u00bb und \u00abWEIBLICH\u00bb untereinander und speichert das Ergebnis in einem neuen Datensatz \u00abALLE_PERSONEN\u00bb: data alle_personen; set maennlich weiblich; run;","title":"DATA STEP"},{"location":"merge.html#proc-append","text":"Eine weitere M\u00f6glichkeit, mittels Programmieren einen Datensatz an einen anderen anzuh\u00e4ngen, ist ein PROC APPEND-Statement. Folgender Code h\u00e4ngt an den Datensatz \u00abMAENNLICH\u00bb den Datensatz \u00abWEIBLICH\u00bb an und \u00fcberschreibt mit dem Ergebnis den urpspr\u00fcnglichen Datensatz \u00abMAENNLICH\u00bb. proc append base=maennlich data=weiblich; run;","title":"PROC APPEND"},{"location":"merge.html#unterschiede-zwischen-den-losungsansatzen","text":"Die verschiedenen L\u00f6sungsans\u00e4tze unterscheiden sich teilweise voneinander. Sehen wir uns an, was passiert, wenn die Variablennamen in den beiden Datens\u00e4tzen nicht identisch geschrieben sind (bspw. Groesse und Gr\u00f6sse): Sowohl die Anwendungsroutine Tabelle anh\u00e4ngen als auch der DATA STEP f\u00fchren zu folgendem Ergebnis: Beim PROC APPEND -Statement hingegen werden die Datens\u00e4tze nicht verbunden und es resultiert stattdessen eine Fehlermeldung: Soll der Append trotzdem durchgef\u00fchrt werden, kann dies mit der Option force erreicht werden: proc append base=maennlich data=weiblich force; run; So werden die Datens\u00e4tze trotzdem aneinandergeh\u00e4ngt. Allerdings werden nur Werte vom Datensatz \u00abWEIBLICH\u00bb angeh\u00e4ngt, wenn die Variablennamen auch im Datensatz \u00abMAENNLICH\u00bb vorkommen:","title":"Unterschiede zwischen den L\u00f6sungsans\u00e4tzen"},{"location":"merge.html#join-mittels-abfrage","text":"Beispiel: Das Gewicht und die Gr\u00f6sse der Zielpersonen ist in zwei separaten Datens\u00e4tzen erfasst. Nun soll ein neuer Datensatz erstellt werden, der beide Angaben enth\u00e4lt. Dazu wird mittels rechtem Mausklick auf einen der beiden Datens\u00e4tze und Abfrage erstellen eine Abfrage erstellt. Mit Hinzuf\u00fcgen wird der zweite Datensatz erg\u00e4nzt. Nun k\u00f6nnen die gew\u00fcnschten Variablen gew\u00e4hlt werden bzw. ins Fenster Daten ausw\u00e4hlen gezogen werden. Hier die Variablen Name und Alter nur einmal ausw\u00e4hlen (bspw. aus dem Datensatz t1). Danach muss unter Tabellen joinen definiert werden, anhand welcher Variablen der Join durchgef\u00fchrt werden und um welche Art von Join (Inner Join, Left Join, Right Join etc.) es sich handeln soll. Es wird automatisch ein Join \u00fcber die Variable Name vorgeschlagen. Da der Name \u00abSandra\u00bb zweimal vorkommt, w\u00e4re ein Join anhand des Namens nicht eindeutig. Deshalb wird der Join zus\u00e4tzlich \u00fcber die Variable Alter ausgef\u00fchrt. Dazu auf die Variable Alter im linken K\u00e4stchen klicken (und halten) und den Cursor r\u00fcber zur Variable Alter im rechten K\u00e4stchen ziehen und loslassen. Die Art des Joins spielt in diesem Beispiel keine Rolle, da in beiden Datens\u00e4tze die gleichen Zielpersonen drin sind und es keine fehlenden Eintr\u00e4ge gibt. Im n\u00e4chsten Abschnitt wird n\u00e4her auf den Unterschied zwischen den verschiedenen Join-Typen eingegangen. Es resultiert folgender Datensatz:","title":"Join mittels Abfrage"},{"location":"merge.html#verschiedene-join-typen","text":"","title":"Verschiedene Join-Typen"},{"location":"merge.html#inner-join","text":"Der neu erzeugte Datensatz enth\u00e4lt nur die Beobachtungen, welche in beiden Ausgangsdatens\u00e4tzen vorkommen. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193","title":"Inner Join"},{"location":"merge.html#left-join","text":"Der neu erzeugte Datensatz enth\u00e4lt nur die Beobachtungen, welche im ersten Ausgangsdatensatz vorkommen. Diejenigen Beobachtungen, welche im zweiten Ausgangsdatensatz nicht vorkommen, weisen f\u00fcr die Variable Gr\u00f6sse einen fehlenden Wert auf. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193","title":"Left Join"},{"location":"merge.html#right-join","text":"Der neu erzeugte Datensatz enth\u00e4lt nur die Beobachtungen, welche im zweiten Ausgangsdatensatz vorkommen. Diejenigen Beobachtungen, welche im ersten Ausgangsdatensatz nicht vorkommen, weisen f\u00fcr die Variable Gewicht einen fehlenden Wert auf. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193","title":"Right Join"},{"location":"merge.html#full-outer-join","text":"Der neu erzeugte Datensatz enth\u00e4lt alle Beobachtungen, die in einem der beiden Ausgangsdatens\u00e4tze vorkommen. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193 Hinweis: Bei den anderen Join-Arten reicht es, die Variablen Name und Alter aus einem der beiden Datens\u00e4tze t1 oder t2 auszuw\u00e4hlen. Beim Full Outer Join funktioniert das nicht. Werden die Variablen aus t1 genommen, dann resultieren fehlende Werte bei derjenigen Beobachtung, die nur in t2 vorkommt und umgekehrt. Um sicherzugehen, dass die Variablen Name und Alter keine fehlenden Werte aufweisen, braucht es einen kleinen Umweg \u00fcber die COALESCE-Funktion bzw. \u00abNeue berechnete Spalte hinzuf\u00fcgen -> Erweiterter Ausdruck\u00bb:","title":"Full Outer Join"},{"location":"neweg.html","text":"SAS Enterprise Guide 8.3 Anwendungsroutinen Die Anwendungsroutinen k\u00f6nnen unter \u00abDatei -> Anwendungsroutinen \u00f6ffnen -> Durchsuchen\u00bb oder auch \u00fcber das entsprechende Symbol weiter rechts in der Men\u00fcleiste aufgerufen werden. Eine der am h\u00e4ufigsten verwendeten Anwendungsroutinen - die Zusammenfassungstabelle - ist bspw. dem Stichwort \u00abBeschreiben\u00bb zugeordnet. Mit Mausklick auf den Stern k\u00f6nnen Anwendungsroutinen als Favorit gespeichert werden. Ist ein Datensatz ge\u00f6ffnet, so k\u00f6nnen die Anwendungsroutinen direkt \u00fcber den Reiter oberhalb des Datensatzes aufgerufen werden. Dort befinden sich auch die gespeicherten Favoriten sowie eine Auflistung der zuletzt verwendeten Anwendungsroutinen. Backup-Intervall Standardm\u00e4ssig wird alle f\u00fcnf Minuten ein Backup f\u00fcr die Automatische Wiederherstellung erstellt. Das dauert jedes Mal ein paar Sekunden und unterbricht somit den Arbeitsfluss erheblich. Unter \u00abExtras -> Optionen -> Automatische Wiederherstellung\u00bb kann das Backup-Intervall angepasst werden. Ein automatisches Backup ist grunds\u00e4tzlich sinnvoll, weshalb empfohlen wird, diese Funktionalit\u00e4t beizubehalten. Bei Bedarf kann das Intervall aber angepasst werden. Zur\u00fcck zum Prozessfluss Wenn im alten Enterprise Guide bspw. ein Datensatz ge\u00f6ffnet war, konnte \u00fcber das Kreuz oben rechts in der Ecke wieder zum Prozessfluss zur\u00fcckgekehrt werden. Im neuen Enterprise Guide gibt es daf\u00fcr mehrere M\u00f6glichkeiten: (1) Den gew\u00fcnschten Prozessfluss \u00fcber die Leiste oben anw\u00e4hlen, (2) den Reiter des ge\u00f6ffneten Datensatzes schliessen oder (3) \u00fcber den Pfeil in der rechten oberen Ecke den gew\u00fcnschten Prozessfluss ausw\u00e4hlen. Das gleiche gilt f\u00fcr das Navigieren hin zu einem Programm oder Datensatz. Nat\u00fcrlich kann auch weiterhin wie bisher \u00fcber die Projekt\u00fcbersicht auf der linken Seite mit Doppelklick ein Prozessfluss, Programm oder Datensatz angew\u00e4hlt werden. Teilung der Programm-Reiter Beim Ausf\u00fchren von Programmen resultiert standardm\u00e4ssig eine vertikale Teilung in ein Fenster \u00abCode\u00bb und ein Fenster mit den Reitern \u00abLog\u00bb und \u00abAusgabedaten\u00bb. Wem das zu un\u00fcbersichtlich ist, kann unter \u00abAnzeigen -> Voreinstellungen f\u00fcr Programm-Reiter\u00bb die Einstellung \u00abStandard\u00bb ausw\u00e4hlen. So wird immer nur ein Programm-Reiter angezeigt und in der Leiste oben kann zwischen den Reitern \u00abCode\u00bb, \u00abLog\u00bb und \u00abAusgabedaten\u00bb gewechselt werden. ERROR: You cannot open... Ist ein Datensatz oben in der Leiste ge\u00f6ffnet, kann er nicht \u00fcberschrieben werden. Das Ausf\u00fchren eines entsprechenden Programms f\u00fchrt dann zur Fehlermeldung \u00abERROR: You cannot open WORK.WOMEN.DATA for output access with member-level control because WORK.WOMEN.DATA is in use by you in resource environment IOM ROOT COMP ENV.\u00bb Um diesen Fehler zu beheben, m\u00fcssen also vor dem Ausf\u00fchren des Programms lediglich alle im Programm referenzierten Datens\u00e4tze in der Leiste oben geschlossen werden.","title":"Enterprise Guide 8.3"},{"location":"neweg.html#sas-enterprise-guide-83","text":"","title":"SAS Enterprise Guide 8.3"},{"location":"neweg.html#anwendungsroutinen","text":"Die Anwendungsroutinen k\u00f6nnen unter \u00abDatei -> Anwendungsroutinen \u00f6ffnen -> Durchsuchen\u00bb oder auch \u00fcber das entsprechende Symbol weiter rechts in der Men\u00fcleiste aufgerufen werden. Eine der am h\u00e4ufigsten verwendeten Anwendungsroutinen - die Zusammenfassungstabelle - ist bspw. dem Stichwort \u00abBeschreiben\u00bb zugeordnet. Mit Mausklick auf den Stern k\u00f6nnen Anwendungsroutinen als Favorit gespeichert werden. Ist ein Datensatz ge\u00f6ffnet, so k\u00f6nnen die Anwendungsroutinen direkt \u00fcber den Reiter oberhalb des Datensatzes aufgerufen werden. Dort befinden sich auch die gespeicherten Favoriten sowie eine Auflistung der zuletzt verwendeten Anwendungsroutinen.","title":"Anwendungsroutinen"},{"location":"neweg.html#backup-intervall","text":"Standardm\u00e4ssig wird alle f\u00fcnf Minuten ein Backup f\u00fcr die Automatische Wiederherstellung erstellt. Das dauert jedes Mal ein paar Sekunden und unterbricht somit den Arbeitsfluss erheblich. Unter \u00abExtras -> Optionen -> Automatische Wiederherstellung\u00bb kann das Backup-Intervall angepasst werden. Ein automatisches Backup ist grunds\u00e4tzlich sinnvoll, weshalb empfohlen wird, diese Funktionalit\u00e4t beizubehalten. Bei Bedarf kann das Intervall aber angepasst werden.","title":"Backup-Intervall"},{"location":"neweg.html#zuruck-zum-prozessfluss","text":"Wenn im alten Enterprise Guide bspw. ein Datensatz ge\u00f6ffnet war, konnte \u00fcber das Kreuz oben rechts in der Ecke wieder zum Prozessfluss zur\u00fcckgekehrt werden. Im neuen Enterprise Guide gibt es daf\u00fcr mehrere M\u00f6glichkeiten: (1) Den gew\u00fcnschten Prozessfluss \u00fcber die Leiste oben anw\u00e4hlen, (2) den Reiter des ge\u00f6ffneten Datensatzes schliessen oder (3) \u00fcber den Pfeil in der rechten oberen Ecke den gew\u00fcnschten Prozessfluss ausw\u00e4hlen. Das gleiche gilt f\u00fcr das Navigieren hin zu einem Programm oder Datensatz. Nat\u00fcrlich kann auch weiterhin wie bisher \u00fcber die Projekt\u00fcbersicht auf der linken Seite mit Doppelklick ein Prozessfluss, Programm oder Datensatz angew\u00e4hlt werden.","title":"Zur\u00fcck zum Prozessfluss"},{"location":"neweg.html#teilung-der-programm-reiter","text":"Beim Ausf\u00fchren von Programmen resultiert standardm\u00e4ssig eine vertikale Teilung in ein Fenster \u00abCode\u00bb und ein Fenster mit den Reitern \u00abLog\u00bb und \u00abAusgabedaten\u00bb. Wem das zu un\u00fcbersichtlich ist, kann unter \u00abAnzeigen -> Voreinstellungen f\u00fcr Programm-Reiter\u00bb die Einstellung \u00abStandard\u00bb ausw\u00e4hlen. So wird immer nur ein Programm-Reiter angezeigt und in der Leiste oben kann zwischen den Reitern \u00abCode\u00bb, \u00abLog\u00bb und \u00abAusgabedaten\u00bb gewechselt werden.","title":"Teilung der Programm-Reiter"},{"location":"neweg.html#error-you-cannot-open","text":"Ist ein Datensatz oben in der Leiste ge\u00f6ffnet, kann er nicht \u00fcberschrieben werden. Das Ausf\u00fchren eines entsprechenden Programms f\u00fchrt dann zur Fehlermeldung \u00abERROR: You cannot open WORK.WOMEN.DATA for output access with member-level control because WORK.WOMEN.DATA is in use by you in resource environment IOM ROOT COMP ENV.\u00bb Um diesen Fehler zu beheben, m\u00fcssen also vor dem Ausf\u00fchren des Programms lediglich alle im Programm referenzierten Datens\u00e4tze in der Leiste oben geschlossen werden.","title":"ERROR: You cannot open..."},{"location":"rawdata.html","text":"Neue Rohdatenablage Der Transfer der Rohdaten vom Datenpool auf die neue Rohdatenablage bringt einen Anpassungsbedarf bei denjenigen SAS-Projekten mit sich, bei welchen Daten direkt vom Datenpool eingelesen werden. Einlesen mit PROC IMPORT Geschieht das Einlesen \u00fcber PROC IMPORT, dann reicht es aus, den Pfad unter DATAFILE anzupassen. Bisher: PROC IMPORT DATAFILE=\"\\\\bs.ch\\dfs\\bs\\pd\\pd-stata\\data\\2_Datenpool\\...\" OUT=Import_Sheet1 DBMS=xlsx REPLACE; SHEET=\"Sheet1\"; GETNAMES=YES; RUN; Neu: PROC IMPORT DATAFILE=\"\\\\pdstatasvdata01\\datenablage\\...\" OUT=Import_Sheet1 DBMS=xlsx REPLACE; SHEET=\"Sheet1\"; GETNAMES=YES; RUN; Anwendungsroutine \u00abDaten importieren\u00bb Werden die Daten mit der Anwendungsroutine \u00abDaten importieren\u00bb eingelesen, dann sieht der Prozessfluss folgendermassen aus: In diesem Fall sind folgende zwei Schritte n\u00f6tig: Rechter Mausklick auf das Excel-Symbol -> Eigenschaften Die Datei \u00fcber den \u00c4ndern-Button am neuen Ablageort suchen","title":"Neue Rohdatenablage"},{"location":"rawdata.html#neue-rohdatenablage","text":"Der Transfer der Rohdaten vom Datenpool auf die neue Rohdatenablage bringt einen Anpassungsbedarf bei denjenigen SAS-Projekten mit sich, bei welchen Daten direkt vom Datenpool eingelesen werden.","title":"Neue Rohdatenablage"},{"location":"rawdata.html#einlesen-mit-proc-import","text":"Geschieht das Einlesen \u00fcber PROC IMPORT, dann reicht es aus, den Pfad unter DATAFILE anzupassen. Bisher: PROC IMPORT DATAFILE=\"\\\\bs.ch\\dfs\\bs\\pd\\pd-stata\\data\\2_Datenpool\\...\" OUT=Import_Sheet1 DBMS=xlsx REPLACE; SHEET=\"Sheet1\"; GETNAMES=YES; RUN; Neu: PROC IMPORT DATAFILE=\"\\\\pdstatasvdata01\\datenablage\\...\" OUT=Import_Sheet1 DBMS=xlsx REPLACE; SHEET=\"Sheet1\"; GETNAMES=YES; RUN;","title":"Einlesen mit PROC IMPORT"},{"location":"rawdata.html#anwendungsroutine-daten-importieren","text":"Werden die Daten mit der Anwendungsroutine \u00abDaten importieren\u00bb eingelesen, dann sieht der Prozessfluss folgendermassen aus: In diesem Fall sind folgende zwei Schritte n\u00f6tig: Rechter Mausklick auf das Excel-Symbol -> Eigenschaften Die Datei \u00fcber den \u00c4ndern-Button am neuen Ablageort suchen","title":"Anwendungsroutine \u00abDaten importieren\u00bb"},{"location":"reports.html","text":"Tabellen und Reports ...Inhalt folgt...","title":"Tabellen und Reports"},{"location":"reports.html#tabellen-und-reports","text":"...Inhalt folgt...","title":"Tabellen und Reports"},{"location":"server.html","text":"Server-Migration Die Server-Migration hat teilweise Auswirkungen auf bestehende SAS-Projekte. In ein paar wenigen F\u00e4llen funktioniert bestehender Code nicht mehr oder wirkt sich anders aus als bisher. Dies betrifft vor allem den Import und Export von Daten. Libname Statements Libname Statements, die explizit den alten Servernamen verwenden, m\u00fcssen angepasst werden: Bisher: libname name '\\\\pdprodsv09\\data\\DWH_Name' access=readonly; Neu: libname name '\\\\pdstatasvpsas05\\data\\DWH_Name' access=readonly; \u00dcberall wo die Libname Statements via \u00abfiledsn\u00bb definiert sind, muss nichts angepasst werden: libname name odbc noprompt='filedsn=\\\\bs.ch\\dfs\\BS\\PD\\PD-StatA\\Programs\\DSN\\prod\\PXY.Z.DWH_Name.dsn;' schema=xyz access=readonly; Export mit ODS Excel Ziel: Ein Excel-File mit je zwei Tabellen pro Tabellenblatt generieren: Bisher konnte das mit folgendem Code erreicht werden: Ein neuer Eintrag bei sheet_name im options-Statement erzeugte ein neues Tabellenblatt in Excel. Die Option sheet_interval=\"none\" verhinderte, dass f\u00fcr jedes Proc Print-Statement ein neues Sheet generiert wird. Das funktioniert nun nicht mehr so. Ein neuer Eintrag bei sheet_name generiert nicht mehr automatisch ein neues Tabellenblatt. Oben gezeigter Code generiert nun ein Excel-File mit nur einem Tabellenblatt \u00abSheet1\u00bb, in dem der Output aller Proc Print-Statements untereinander geschrieben wird. Neu ist folgender Code n\u00f6tig: Immer wenn ein neues Tabellenblatt erzeugt werden soll, ist die Option sheet_interval=\"now\" n\u00f6tig.","title":"Server-Migration"},{"location":"server.html#server-migration","text":"Die Server-Migration hat teilweise Auswirkungen auf bestehende SAS-Projekte. In ein paar wenigen F\u00e4llen funktioniert bestehender Code nicht mehr oder wirkt sich anders aus als bisher. Dies betrifft vor allem den Import und Export von Daten.","title":"Server-Migration"},{"location":"server.html#libname-statements","text":"Libname Statements, die explizit den alten Servernamen verwenden, m\u00fcssen angepasst werden: Bisher: libname name '\\\\pdprodsv09\\data\\DWH_Name' access=readonly; Neu: libname name '\\\\pdstatasvpsas05\\data\\DWH_Name' access=readonly; \u00dcberall wo die Libname Statements via \u00abfiledsn\u00bb definiert sind, muss nichts angepasst werden: libname name odbc noprompt='filedsn=\\\\bs.ch\\dfs\\BS\\PD\\PD-StatA\\Programs\\DSN\\prod\\PXY.Z.DWH_Name.dsn;' schema=xyz access=readonly;","title":"Libname Statements"},{"location":"server.html#export-mit-ods-excel","text":"Ziel: Ein Excel-File mit je zwei Tabellen pro Tabellenblatt generieren: Bisher konnte das mit folgendem Code erreicht werden: Ein neuer Eintrag bei sheet_name im options-Statement erzeugte ein neues Tabellenblatt in Excel. Die Option sheet_interval=\"none\" verhinderte, dass f\u00fcr jedes Proc Print-Statement ein neues Sheet generiert wird. Das funktioniert nun nicht mehr so. Ein neuer Eintrag bei sheet_name generiert nicht mehr automatisch ein neues Tabellenblatt. Oben gezeigter Code generiert nun ein Excel-File mit nur einem Tabellenblatt \u00abSheet1\u00bb, in dem der Output aller Proc Print-Statements untereinander geschrieben wird. Neu ist folgender Code n\u00f6tig: Immer wenn ein neues Tabellenblatt erzeugt werden soll, ist die Option sheet_interval=\"now\" n\u00f6tig.","title":"Export mit ODS Excel"},{"location":"stichproben.html","text":"Stichprobenanalyse","title":"Stichprobenanalyse"},{"location":"stichproben.html#stichprobenanalyse","text":"","title":"Stichprobenanalyse"},{"location":"transp.html","text":"Transponieren Die Anwendungsroutine \u00abTransponieren\u00bb erm\u00f6glicht es, die Struktur eines Datensatzes zu \u00e4ndern. Der Datensatz kann entweder vertikal oder horizontal strukturiert sein. Beispiel: Ein Datensatz enth\u00e4lt f\u00fcr jede Person drei numerische Variablen - das Alter, die Gr\u00f6sse und das Gewicht. In der vertikalen Form sind die Werte f\u00fcr Alter, Gr\u00f6sse und Gewicht alle untereinander, also in einer Variable, erfasst. F\u00fcr jede Person im Datensatz sind also drei Beobachtungen vorhanden. In der horizontalen Form sind die Werte auf drei verschiedene Variablen aufgeteilt, folglich existiert nur eine Beobachtung pro Person. Horizontalisierung Liegen die Daten in der vertikalen Form vor, werden aber f\u00fcr die Weiterverarbeitung in der horizontalen Form gebraucht, so kann das mittels \u00abTransponieren\u00bb erreicht werden. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193 L\u00f6sungsweg SAS Enterprise Guide Schritt 1 : Anwendungsroutine \u00abTransponieren\u00bb ausw\u00e4hlen. Wo diese im neuen SAS Enterprise Guide zu finden ist, kann hier nachgelesen werden. Schritt 2 : Die Variablen den richtigen Rollen zuordnen: Variable transponieren : Hier muss die Analysevariable ausgew\u00e4hlt werden, deren Werte auf verschiedene Spalten aufgeteilt werden sollen. In diesem Beispiel also Wert . Neue Spaltennamen (Maximal: 1) : Hier wird die Variable ausgew\u00e4hlt, deren Auspr\u00e4gungen die neuen Variablen bilden bzw. benennen sollen. In diesem Beispiel also Merkmal . Analyse gruppieren nach : In diesem Beispiel die Variablen Name und Geschlecht . Hier k\u00f6nnen auch noch mehr Variablen gew\u00e4hlt werden, z.B. wenn der Wert nicht nur nach Name und Geschlecht, sondern z.B. auch noch nach Nationalit\u00e4t ausgewiesen wird. Schritt 3 : Das H\u00e4kchen bei \u00abPr\u00e4fix verwenden\u00bb rausnehmen, damit die neuen Spaltennamen nicht mit dem Wort \u00abSpalte\u00bb (Default) erg\u00e4nzt werden. Vertikalisierung Liegen die Daten in der horizontalen Form vor, werden aber f\u00fcr die Weiterverarbeitung in der vertikalen Form gebraucht, so kann das ebenfalls mittels \u00abTransponieren\u00bb erreicht werden. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193 L\u00f6sungsweg SAS Enterprise Guide Schritt 1 : Anwendungsroutine \u00abTransponieren\u00bb ausw\u00e4hlen. Schritt 2 : Die Variablen den richtigen Rollen zuordnen: Variable transponieren : Hier m\u00fcssen die Analysevariablen ausgew\u00e4hlt werden, deren Werte in einer Spalte zusammengefasst werden sollen. In diesem Beispiel also Alter , Gr\u00f6sse und Gewicht . Analyse gruppieren nach : In diesem Beispiel die Variablen Name und Geschlecht . Hier k\u00f6nnen auch noch mehr Variablen gew\u00e4hlt werden, z.B. wenn der Wert nicht nur nach Name und Geschlecht, sondern z.B. auch noch nach Nationalit\u00e4t ausgewiesen w\u00fcrde. Schritt 3 : Namen f\u00fcr Quellspalte setzen, in diesem Fall soll sie Merkmal heissen.","title":"Transponieren"},{"location":"transp.html#transponieren","text":"Die Anwendungsroutine \u00abTransponieren\u00bb erm\u00f6glicht es, die Struktur eines Datensatzes zu \u00e4ndern. Der Datensatz kann entweder vertikal oder horizontal strukturiert sein. Beispiel: Ein Datensatz enth\u00e4lt f\u00fcr jede Person drei numerische Variablen - das Alter, die Gr\u00f6sse und das Gewicht. In der vertikalen Form sind die Werte f\u00fcr Alter, Gr\u00f6sse und Gewicht alle untereinander, also in einer Variable, erfasst. F\u00fcr jede Person im Datensatz sind also drei Beobachtungen vorhanden. In der horizontalen Form sind die Werte auf drei verschiedene Variablen aufgeteilt, folglich existiert nur eine Beobachtung pro Person.","title":"Transponieren"},{"location":"transp.html#horizontalisierung","text":"Liegen die Daten in der vertikalen Form vor, werden aber f\u00fcr die Weiterverarbeitung in der horizontalen Form gebraucht, so kann das mittels \u00abTransponieren\u00bb erreicht werden. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193","title":"Horizontalisierung"},{"location":"transp.html#losungsweg-sas-enterprise-guide","text":"Schritt 1 : Anwendungsroutine \u00abTransponieren\u00bb ausw\u00e4hlen. Wo diese im neuen SAS Enterprise Guide zu finden ist, kann hier nachgelesen werden. Schritt 2 : Die Variablen den richtigen Rollen zuordnen: Variable transponieren : Hier muss die Analysevariable ausgew\u00e4hlt werden, deren Werte auf verschiedene Spalten aufgeteilt werden sollen. In diesem Beispiel also Wert . Neue Spaltennamen (Maximal: 1) : Hier wird die Variable ausgew\u00e4hlt, deren Auspr\u00e4gungen die neuen Variablen bilden bzw. benennen sollen. In diesem Beispiel also Merkmal . Analyse gruppieren nach : In diesem Beispiel die Variablen Name und Geschlecht . Hier k\u00f6nnen auch noch mehr Variablen gew\u00e4hlt werden, z.B. wenn der Wert nicht nur nach Name und Geschlecht, sondern z.B. auch noch nach Nationalit\u00e4t ausgewiesen wird. Schritt 3 : Das H\u00e4kchen bei \u00abPr\u00e4fix verwenden\u00bb rausnehmen, damit die neuen Spaltennamen nicht mit dem Wort \u00abSpalte\u00bb (Default) erg\u00e4nzt werden.","title":"L\u00f6sungsweg SAS Enterprise Guide"},{"location":"transp.html#vertikalisierung","text":"Liegen die Daten in der horizontalen Form vor, werden aber f\u00fcr die Weiterverarbeitung in der vertikalen Form gebraucht, so kann das ebenfalls mittels \u00abTransponieren\u00bb erreicht werden. \u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002\u2002 \u2193","title":"Vertikalisierung"},{"location":"transp.html#losungsweg-sas-enterprise-guide_1","text":"Schritt 1 : Anwendungsroutine \u00abTransponieren\u00bb ausw\u00e4hlen. Schritt 2 : Die Variablen den richtigen Rollen zuordnen: Variable transponieren : Hier m\u00fcssen die Analysevariablen ausgew\u00e4hlt werden, deren Werte in einer Spalte zusammengefasst werden sollen. In diesem Beispiel also Alter , Gr\u00f6sse und Gewicht . Analyse gruppieren nach : In diesem Beispiel die Variablen Name und Geschlecht . Hier k\u00f6nnen auch noch mehr Variablen gew\u00e4hlt werden, z.B. wenn der Wert nicht nur nach Name und Geschlecht, sondern z.B. auch noch nach Nationalit\u00e4t ausgewiesen w\u00fcrde. Schritt 3 : Namen f\u00fcr Quellspalte setzen, in diesem Fall soll sie Merkmal heissen.","title":"L\u00f6sungsweg SAS Enterprise Guide"},{"location":"MDs%20mit%20Inhaltsverzeichnis/abfrage.html","text":"Abfrage erstellen Auswahl, Filtern, Sortieren Zusammenfassungsfunktionen Neue Variable erstellen Eingabeaufforderungen","title":"Abfrage erstellen"},{"location":"MDs%20mit%20Inhaltsverzeichnis/abfrage.html#abfrage-erstellen","text":"","title":"Abfrage erstellen"},{"location":"MDs%20mit%20Inhaltsverzeichnis/abfrage.html#auswahl-filtern-sortieren","text":"","title":"Auswahl, Filtern, Sortieren"},{"location":"MDs%20mit%20Inhaltsverzeichnis/abfrage.html#zusammenfassungsfunktionen","text":"","title":"Zusammenfassungsfunktionen"},{"location":"MDs%20mit%20Inhaltsverzeichnis/abfrage.html#neue-variable-erstellen","text":"","title":"Neue Variable erstellen"},{"location":"MDs%20mit%20Inhaltsverzeichnis/abfrage.html#eingabeaufforderungen","text":"","title":"Eingabeaufforderungen"}]}